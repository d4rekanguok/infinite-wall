{"version":3,"file":"index.mjs","sources":["../src/react/index.js"],"sourcesContent":["import React from \"react\";\nimport Hammer from \"hammerjs\";\n\nconst getSlotGridConfig = ({ wallBounding, config }) => {\n  const { width, height } = wallBounding;\n  const { width: slotW, height: slotH, gap } = config;\n\n  const slotCols = Math.round(width / (slotW + gap)) + 1;\n  const slotRows = Math.round(height / (slotH + gap)) + 1;\n  const slotAmount = slotCols * slotRows;\n\n  const slotTotalWidth = (slotW + gap) * slotCols;\n  const slotTotalHeight = (slotH + gap) * slotRows;\n\n  return {\n    slotCols,\n    slotRows,\n    slotAmount,\n    slotTotalWidth,\n    slotTotalHeight\n  };\n};\n\nconst getContentGridConfig = ({ config, contentSize }) => {\n  const { gap, cols: contentCols, width: slotW, height: slotH } = config;\n  const contentRows = Math.ceil(contentSize / contentCols);\n\n  const contentTotalWidth = (slotW + gap) * contentCols;\n  const contentTotalHeight = (slotH + gap) * contentRows;\n\n  return {\n    contentCols,\n    contentRows,\n    contentTotalWidth,\n    contentTotalHeight\n  };\n};\n\nconst getSlotGridPos = (i = 0, cols) => {\n  const col = i % cols;\n  const row = ~~(i / cols);\n  return { row, col };\n};\n\nclass Infinite extends React.PureComponent {\n  constructor(props) {\n    super(props);\n\n    // react\n    this.state = {\n      isReady: false,\n    };\n    this.wallRef = React.createRef();\n\n    // component\n    this.slots = [];\n    this.loopCount = {\n      x: 0,\n      y: 0\n    };\n    this.contentRootPos = {\n      x: 0,\n      y: 0\n    };\n    this.slotRootPos = {\n      x: 0,\n      y: 0\n    };\n\n    this.wallBounding = {};\n    this.config = {};\n    this.slotConfig = {};\n    this.contentConfig = {};\n\n    this.updateRootPos = this.updateRootPos.bind(this);\n    this.goToPos = this.goToPos.bind(this);\n    this.snap = this.snap.bind(this);\n  }\n\n  componentDidMount() {\n    const $wall = this.wallRef.current;\n\n    this.wallBounding = $wall.getBoundingClientRect();\n    const wallBounding = this.wallBounding;\n\n    // TODOS: parse config (%, etc.) & make correct dimension here\n\n    this.config = {\n      ...this.props.config,\n      width: this.wallBounding.width / 4,\n      height: 200\n    };\n\n    const config = this.config;\n    const { contentSize } = config;\n    // setup meaurement\n\n    const contentRootPos = {\n      x: -this.config.width * -0.5,\n      y: -this.config.height * -0.5\n    };\n\n    this.contentRootPos = { ...contentRootPos };\n    this.slotRootPos = { ...contentRootPos };\n\n    // slot configs\n    this.slotConfig = getSlotGridConfig({ wallBounding, config });\n    this.contentConfig = getContentGridConfig({ contentSize, config });\n\n    let distanceX = 0;\n    let distanceY = 0;\n\n    // mousewheel events\n    let timer = null;\n    $wall.onwheel = e => {\n      e.stopPropagation();\n\n      const { deltaX, deltaY } = e;\n      const { x, y } = this.contentRootPos;\n\n      // total distance from original position\n      const newRootPosY = y - deltaY;\n      const newRootPosX = x - deltaX;\n\n      this.updateRootPos({ x: newRootPosX, y: newRootPosY });\n      this.updateSlots();\n\n      // snap when scroll stops\n      clearTimeout(timer);\n      timer = setTimeout(() => {\n        this.snap({ duration: 200 });\n      }, 100);\n    };\n\n    // support keyboard arrows;\n    window.onkeydown = e => {\n      const { keyCode } = e;\n      if (keyCode > 40 || keyCode < 37) return;\n\n      const { x, y } = this.contentRootPos;\n      const { gap, width: w, height: h } = this.config;\n\n      let newRootPosX = x;\n      let newRootPosY = y;\n\n      switch (keyCode) {\n        case 40:\n          // key: arrowDown;\n          newRootPosY += gap + h;\n          break;\n        case 39:\n          // key: arrowRight;\n          newRootPosX += gap + w;\n          break;\n        case 38:\n          // key: arrowUp;\n          newRootPosY -= gap + h;\n          break;\n        case 37:\n          // key: arrowLeft;\n          newRootPosX -= gap + w;\n          break;\n        default:\n      }\n\n      this.goToPos({ x: newRootPosX, y: newRootPosY }, { duration: 150 });\n    };\n\n    const hammer = new Hammer.Manager($wall);\n    hammer.add(\n      new Hammer.Pan({ direction: Hammer.DIRECTION_ALL, threshold: 0 })\n    );\n\n    hammer.on(\"panstart\", e => {\n      console.log(\"panstart\");\n      const { x, y } = e.center;\n      // distance from pointer to current content root\n      const contentRootPos = this.contentRootPos;\n      distanceY = y - contentRootPos.y;\n      distanceX = x - contentRootPos.x;\n    });\n\n    hammer.on(\"panmove\", e => {\n      const { x, y } = e.center;\n\n      // total distance from original position\n      const newRootPosY = y - distanceY;\n      const newRootPosX = x - distanceX;\n\n      this.updateRootPos({ x: newRootPosX, y: newRootPosY });\n      this.updateSlots();\n    });\n\n    hammer.on(\"panend\", e => {\n      console.log(\"panend\");\n      this.snap();\n    });\n\n    this.createSlots();\n\n    this.setState({ \n      isReady: true,\n    });\n  }\n\n  updateRootPos(distance = { x: 0, y: 0 }) {\n    const { x, y } = distance;\n    const { slotTotalWidth, slotTotalHeight } = this.slotConfig;\n    const { contentTotalWidth, contentTotalHeight } = this.contentConfig;\n\n    const { contentRootPos, slotRootPos, loopCount } = this;\n\n    // loop content\n    contentRootPos.y = y % contentTotalHeight;\n    contentRootPos.x = x % contentTotalWidth;\n\n    // keep track of loop count so we can place correct data on slot\n    // since we're counting from the bottom right position (hence Math.ceil)\n    // if loop count > 0, remove 1 loop to make it seamless\n    loopCount.y = -Math.ceil(y / slotTotalHeight);\n    if (loopCount.y < 0) loopCount.y++;\n    loopCount.x = -Math.ceil(x / slotTotalWidth);\n    if (loopCount.x < 0) loopCount.x++;\n\n    // loop slot\n    slotRootPos.y = y % slotTotalHeight;\n    slotRootPos.x = x % slotTotalWidth;\n  }\n\n  snap(setting = { duration: 150 }) {\n    const { snap, gap, width: w, height: h } = this.config;\n\n    if (!snap) return;\n\n    const { x:rootPosX, y:rootPosY } = this.contentRootPos;\n    const snapY = h + gap;\n    const snapX = w + gap;\n    const offsetY = snapY / 2;\n    const offsetX = snapX / 2;\n    \n    const newPosY = snapY * Math.round((rootPosY - offsetY) / snapY) + offsetY;\n    const newPosX = snapX * Math.round((rootPosX - offsetX) / snapX) + offsetX;\n\n    this.goToPos({\n      x: newPosX,\n      y: newPosY,\n    }, setting);\n  }\n\n  goToPos(toPos = {x: 0, y: 0}, setting = {\n    duration: 0,\n  }) {\n    const { duration } = setting;\n\n    if (duration === 0) {\n      this.updateRootPos(toPos);\n      this.updateSlots();\n      return;\n    }\n\n    const fromPos = {...this.contentRootPos};\n\n    let start = null;\n    const newPos = {x: 0, y: 0};\n    const updateRootPos = this.updateRootPos.bind(this);\n    const updateSlots = this.updateSlots.bind(this);\n\n    function render (timestamp) {\n      if (!start) start = timestamp;\n      const delta = timestamp - start;\n      newPos.x = fromPos.x + (toPos.x - fromPos.x) / duration * delta;\n      newPos.y = fromPos.y + (toPos.y - fromPos.y) / duration * delta;\n\n      updateRootPos(newPos);\n      updateSlots();\n      \n      if (delta < duration) window.requestAnimationFrame(render);\n    }\n    \n    window.requestAnimationFrame(render);\n  }\n\n  createSlots() {\n    if (this.slots.length > 0) {\n      console.error(\"slots had alisReady been created.\");\n      return;\n    }\n    const { slotAmount, slotCols } = this.slotConfig;\n    const { width: w, height: h } = this.config;\n\n    const head = document.head;\n    const css = document.createElement(\"style\");\n    css.type = \"text/css\";\n    css.appendChild(\n      document.createTextNode(`\n      .infinite-wall-slot {\n        position: absolute;\n        display: block;\n        box-sizing: border-box;\n        top: 0; left: 0;\n        width: ${w}px; height: ${h}px;\n      }\n      `)\n    );\n    head.appendChild(css);\n\n    for (let i = 0; i < slotAmount; i++) {\n      const gridPos = getSlotGridPos(i, slotCols);\n      const ref = React.createRef();\n      this.slots.push({\n        gridPos,\n        ref\n      });\n    }\n  }\n  \n  updateSlots() {\n    if (!this.state.isReady) return;\n    this.slots.forEach(slot => {\n      const Slot = slot.ref.current;\n      Slot.updateSlot(this.slotRootPos, this.loopCount);\n    })\n  }\n\n  render() {\n    const { isReady } = this.state;\n    const { slotConfig, contentConfig, config, slotRootPos } = this;\n    return (\n      <ul style={{\n        position: 'absolute',\n        margin: 0,\n        padding: 0,\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        overflow: 'hidden',\n      }} ref={this.wallRef}>\n        {isReady && this.slots.map(({gridPos, ref}, i) => (\n          <Slot\n            ref={ref}\n            key={i}\n            id={i}\n            gridPos={gridPos}\n            slotConfig={slotConfig}\n            config={config}\n            contentConfig={contentConfig}\n            initPos={slotRootPos}\n            render={this.props.render}\n            />\n        ))}\n      </ul>\n    );\n  }\n}\n\nclass Slot extends React.PureComponent {\n  constructor (props) {\n    super(props);\n    this.ref = React.createRef();\n    this.id = this.props.id;\n\n    this.state = {\n      contentId: 0,\n    }\n\n    this.updateSlot = this.updateSlot.bind(this);\n    this.getSlotPosFromRootPos = this.getSlotPosFromRootPos.bind(this);\n  }\n\n  componentDidMount() {\n    this.updateSlot(this.props.initPos);\n  }\n\n  updateSlot(slotRootPos, loopCount) {\n    const { contentId:currentId } = this.state;\n    const { slotX, slotY, col, row } = this.getSlotPosFromRootPos(slotRootPos);\n    const { contentId } = this.updateContent({col, row}, loopCount);\n\n    if (contentId !== currentId) this.setState({ contentId });\n    this.ref.current.style = `transform: translate(${slotX}px, ${slotY}px);`;\n  }\n\n  getSlotPosFromRootPos(slotRootPos = { x: 0, y: 0}) {\n    const { slotConfig, gridPos, config } = this.props;\n    const { slotCols, slotRows } = slotConfig;\n    const { x: rootX, y: rootY } = slotRootPos;\n    const { width: slotW, height: slotH, gap } = config;\n\n    let { col, row } = gridPos;\n    // amount of slot that'll fit into the distance between rootX and this slot\n    // basically, if slot's not in view -> move it to the other side of the grid\n    const slotHorizontalDistance = Math.ceil(rootX / (slotW + gap)) + col;\n    if (slotHorizontalDistance >= slotCols) col = col - slotCols;\n    if (slotHorizontalDistance < 0) col = col + slotCols;\n  \n    const slotVerticalDistance = Math.ceil(rootY / (slotH + gap)) + row;\n    if (slotVerticalDistance >= slotRows) row = row - slotRows;\n    if (slotVerticalDistance < 0) row = row + slotRows;\n\n    const slotX = rootX + col * (slotW + gap);\n    const slotY = rootY + row * (slotH + gap);\n\n    return { slotY, slotX, col, row };\n  }\n\n  updateContent(slotGridPos = { col: 0, row: 0 }, loopCount={x:0,y:0}) {\n    const { slotConfig, contentConfig, config } = this.props;\n    const { contentSize } = config;\n    const { col, row } = slotGridPos;\n    const { slotCols, slotRows } = slotConfig;\n    const { contentCols, contentRows } = contentConfig;\n    const { x: loopX, y: loopY } = loopCount;\n\n    let contentCol, contentRow;\n\n    // Content\n    contentCol = (col + loopX * slotCols) % contentCols;\n    contentRow = (row + loopY * slotRows) % contentRows;\n\n    let contentId = contentRow * contentCols + contentCol;\n    if (contentId < 0) contentId = contentId + contentSize;\n    if (contentId > contentSize) contentId = null\n\n    return {\n      contentCol,\n      contentRow,\n      contentId,\n    }\n  }\n\n  render () {\n    const { render } = this.props;\n    const data = {\n      id: this.id,\n      contentId: this.state.contentId,\n    }\n    return <li className=\"infinite-wall-slot\" ref={this.ref}>{\n      render({ data })\n    }</li>\n  }\n}\n\nexport default Infinite;\n"],"names":["const","getSlotGridPos","i","cols","Infinite","constructor","props","state","isReady","wallRef","React","createRef","slots","loopCount","x","y","contentRootPos","slotRootPos","wallBounding","config","slotConfig","contentConfig","updateRootPos","this","bind","goToPos","snap","componentDidMount","$wall","current","getBoundingClientRect","Object","width","height","ref","slotCols","Math","round","slotW","gap","slotRows","slotH","getSlotGridConfig","contentRows","ceil","contentCols","getContentGridConfig","contentSize","distanceX","distanceY","timer","onwheel","e","stopPropagation","updateSlots","clearTimeout","setTimeout","duration","window","onkeydown","keyCode","newRootPosX","newRootPosY","h","w","hammer","Hammer","Manager","add","Pan","direction","DIRECTION_ALL","threshold","on","console","log","center","createSlots","setState","distance","contentTotalWidth","slotTotalHeight","slotTotalWidth","setting","snapY","snapX","offsetY","offsetX","newPosY","newPosX","rootPosX","toPos","fromPos","start","newPos","requestAnimationFrame","render","timestamp","delta","length","error","head","document","css","createElement","type","appendChild","createTextNode","let","slotAmount","gridPos","push","forEach","slot","updateSlot","style","position","margin","padding","top","left","overflow","map","ref$1","Slot","key","id","initPos","PureComponent","contentId","getSlotPosFromRootPos","updateContent","currentId","slotX","slotY","slotHorizontalDistance","rootX","col","slotVerticalDistance","rootY","row","slotGridPos","contentCol","contentRow","className"],"mappings":"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"}